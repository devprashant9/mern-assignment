# Student Job Tracker Assignment Walk Through

## Project Folder Structure With Details About Each File

In this section I have discussed importance of each and every file used in the folder structure. These are not random but more like industry based applications.

## Client Side Folder Structure

<pre>
|--------public
|--------src
|          |-------assets
|          |-------components
|          |-------pages
|          |-------services
|--------App.jsx
|--------main.jsx
|--------index.css
|--------index.html
</pre>

<u>`i. index.html:`</u> Basically we only have only HTML page that is why React Apps are also known as Single Page Applications and this is the entry point of our react application.

<u>`ii. main.jsx:`</u> This file helps to bind the HTML and the other react pages or components and also acts as a wrapper for the App component.

<u>`iii. App.jsx:`</u> This is the component that entirely wraps our react application like all the router and what components needs to be rendered.

<u>`iv. src:`</u> This is the heart folder where all important folders are located. Mainly we have a **components** folder where we keep our resubale codes and the **pages** folder that actually does the display job. Apart from that we can have any number of folders like **hooks** depending upon different use case.

<u>`v. public:`</u> ALl the static files that needs to be renderd on client side are kept in this folder and it is automatically detected by the application.

## Server Side Folder Structure

<pre>
|--------configs
|           |-------config.js
|           |-------db.js
|--------controllers
|                  |-------jobControllers.js
|--------middlewares
|                  |-------notFound.js
|                  |-------errorHandler.js
|--------models
|             |-------jobApplications.models.js
|--------routes
|             |-------jobRoutes.js
|--------.env
|--------server.js
|
|--------node_modules
|--------package-lock.json
|--------package.json

</pre>

<u>`i. configs:`</u> This folder contains a file named **config.js**, which is used to create an object from the **.env** file. This object is then _freezed_ so that its properties and values cannot be changed. This approach is commonly used in larger applications because it avoids the need to repeatedly write **process.env.VARIABLE_NAME** and helps in managing secret keys more securely.

The second file, **db.js**, is used to create a connection with MongoDB using the _Mongoose Object Data Modelling (ODM)_ library. **Mongoose** is a library built on top of the _MongoDB Native Driver_ and allows us to work in an object-oriented manner.

<u>`ii. controllers:`</u> The main purpose of this folder is to keep our logic separated and organized for better readability and to keep our code cleaner. We can have multiple files inside this folder, but we usually keep one controller per resource.

For example, if we are working with a Job resource, then all the APIs related to jobs should be inside one controller file. In the same way, each resource should have its own controller file.

<u>`iii. middlewares:`</u> This folder is important because middleware works like a security guard for all routes. Whenever the client calls any API, the request first passes through middleware.

We can use middleware in two ways — globally for all routes, or only for specific routes. Global middleware is usually written at the top of the main file, like server.js. After checking or processing the request, it sends it forward to the route’s actual logic. Also, we can use more than one middleware on a single route if needed.

<u>`iv. models:`</u> This folder is considered the **heart** of the backend, because it contains all the _schemas_ that define the structure of the data we want to store in our database.

When we create a model, we define a **schema name**, and MongoDB automatically stores it in _plural format_ (for example, a model named **Job** will be saved in the **jobs** collection). Each _document_ stored in the database also gets a unique **\_id** by default, which is automatically generated by MongoDB. This \_id is used to uniquely identify and reference documents.

Models are created using Mongoose, and they allow us to interact with the database in an object-oriented and structured way.

<u>`v. routes:`</u> This folder is used to define all the _API endpoints_ that our application will handle. Instead of writing all the routes directly in the main file (like server.js), we keep them in separate route files to make the code more organized, readable, and maintainable.

Each route file is usually related to a _specific resource_. For example, if we have a resource called Job, then all the routes related to job operations (like create, read, update, delete) are defined inside a file like jobRoutes.js.

We use **app.use()** in the main file to connect these route files with the main application.

Using a routes folder also makes it **easier to scale** the application when it grows, as we can manage different features in different route files without cluttering the main entry point.

<u>`vi. .env:`</u> This file is very important because it stores all the **API keys, database URLs, and other secret configuration values** needed by our application to connect with third-party services or external tools. Without this file, many parts of the app would not function properly.

The **.env** file helps us keep sensitive information separate from our code, which improves both security and flexibility. It should never be shared or pushed to public repositories, and it's usually listed in **.gitignore** to prevent accidental exposure.

By loading this file using libraries like dotenv, we can access the values easily using _process.env.KEY_NAME_ anywhere in our app.

<u>`viii. package.json:`</u> This file is like the blueprint of the project. It contains important information such as the project name, version, description, scripts, and most importantly, the list of dependencies and devDependencies that the app needs to run. It helps others know which packages are required and also allows tools like npm or yarn to install those packages easily.

<u>`ix. package-lock.json:`</u> This file is automatically generated when you install npm packages. It locks the versions of all the packages and their sub-dependencies to ensure that everyone using the project gets the exact same versions, avoiding bugs or issues caused by version changes. It improves consistency and reliability across different machines and environments.

<u>`x. node_modules:`</u> This folder contains all the actual installed packages and dependencies used in the project. Whenever you run npm install, all the libraries listed in package.json get downloaded into this folder. It is a heavy folder, and it should not be pushed to version control (like GitHub), because anyone can regenerate it using package.json.

## Role of AI Chat Models in This Project

While working on this small assessment project, AI has been incredibly helpful, especially in identifying bugs and pointing out mistakes in my code. It acted like a support system that was always available whenever I got stuck.

However, since AI models are trained on past data, there were times when they provided older code snippets that included deprecated properties or methods. This reminded me how important it is, as a developer, to stay updated with the official documentation of the libraries or frameworks we’re using.

Even if I didn’t fully understand some parts of the documentation, I would share those references with the AI model and prompt it to generate the latest and correct syntax based on that. This made the experience more efficient and aligned with modern standards.

Throughout the development, I followed the DRY (Don't Repeat Yourself) principle. I tried to keep my functions independent and reusable, and here again, AI supported me by helping clean and organize the code structure.

One important thing I realised is that AI doesn't know the exact requirements of a project unless we clearly communicate them. So, when I gave it well-structured data and clear instructions, it worked much better — faster, more accurately, and with fewer errors.
